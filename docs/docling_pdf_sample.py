# -*- coding: utf-8 -*-
"""Docling_Pdf.ipynb のコピー

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12uO3XHKncriLmNsm4FVw07LRfxChhM3L
"""

!pip install -q docling pillow
!

!pip show docling docling-core

# 環境に合わせてPDFパスを指定
from pathlib import Path
import subprocess
import sys


PDF_PATH = Path("sample_arxiv.pdf")  # 例
OUT_DIR = Path("extracted_output")

# PDFダウンロード
ARXIV_PDF_URL = "https://arxiv.org/pdf/1706.03762.pdf" # Attention is All You Need
print(f"Downloading PDF from {ARXIV_PDF_URL} to {PDF_PATH}")
try:
    subprocess.run(['wget', '-q', '-O', str(PDF_PATH), ARXIV_PDF_URL], check=True)
    print(f"Downloaded: {PDF_PATH.exists()} -> {PDF_PATH}")
except subprocess.CalledProcessError as e:
    print(f"Error downloading PDF: {e}", file=sys.stderr)
    sys.exit(1)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile config.yaml
# input_dir: /content
# output_dir: docling_output_vlm_rag_improved
# images_subdir: images
# image_scale: 2.0
# encoding: utf-8
# retry_attempts: 3
# retry_wait: 2

!pip install --quiet pymupdf pdfplumber Pillow pymupdf4llm

# -*- coding: utf-8 -*-
"""
pdf_to_markdown_with_images.py

Purpose:
- Convert a PDF to Markdown with linked images using pymupdf4llm.
- Save images to an 'images' subdirectory with relative paths (e.g., images/sample_arxiv.pdf-2-0.png).
- Convert image references to HTML <figure> tags with captions.
- Ensure robust error handling and logging.
- Zip outputs for easy download (Colab-compatible).

Dependencies:
- pymupdf, pymupdf4llm, Pillow, requests
- Install: pip install pymupdf pymupdf4llm pillow requests

Usage:
- Set PDF_PATH and OUT_DIR at the top or pass via command line.
- Run in a notebook (e.g., Colab) or as a script.
"""

import os
from pathlib import Path
import re
import html
import logging
import zipfile
import requests
from typing import Optional, List, Tuple
import fitz  # pymupdf
import pymupdf4llm

# --- Configuration ---
ARXIV_PDF_URL = "https://arxiv.org/pdf/1706.03762.pdf"  # Fallback PDF URL
PDF_PATH = Path("sample_arxiv.pdf")  # Input PDF
OUT_DIR = Path("extracted_output")   # Output directory
MD_OUTPUT_NAME = "extracted_document.md"  # Output Markdown file
IMAGE_DIR_NAME = "images"           # Subdirectory for images
ZIP_PATH = "extracted_output.zip"   # Output zip file
DPI = 300                          # DPI for image extraction
VERBOSE = True                     # Enable verbose logging

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(f"pdf_to_markdown_{Path(PDF_PATH).stem}.log")
    ]
)
logger = logging.getLogger(__name__)

def vprint(*args, **kwargs):
    """Verbose print function."""
    if VERBOSE:
        logger.info(" ".join(map(str, args)))

def download_pdf(url: str, pdf_path: Path) -> bool:
    """
    Download a PDF from a URL if it doesn't exist.

    Args:
        url (str): URL to download the PDF.
        pdf_path (Path): Path to save the PDF.

    Returns:
        bool: True if download succeeded or file exists, False otherwise.
    """
    if pdf_path.exists():
        vprint(f"PDF already exists: {pdf_path}")
        return True
    try:
        pdf_path.parent.mkdir(parents=True, exist_ok=True)
        response = requests.get(url, stream=True)
        if response.status_code == 200:
            with open(pdf_path, 'wb') as f:
                f.write(response.content)
            vprint(f"Downloaded PDF from {url} to {pdf_path}")
            return True
        else:
            logger.error(f"Failed to download PDF from {url}: Status {response.status_code}")
            return False
    except Exception as e:
        logger.error(f"Download failed: {e}")
        return False

def choose_safe_flag() -> int:
    """
    Select a safe text extraction flag for PyMuPDF.

    Returns:
        int: Selected flag (e.g., TEXTFLAGS_TEXT or fallback to 1).
    """
    candidates = ["TEXTFLAGS_TEXT", "TEXT_FLAGS_TEXT", "TEXTFLAGS_SIMPLE", "TEXTFLAGS_NONE"]
    for candidate in candidates:
        if hasattr(fitz, candidate):
            flag = getattr(fitz, candidate)
            vprint(f"Using flag: fitz.{candidate} -> {flag}")
            return int(flag)
    vprint("No TEXTFLAGS_* found. Falling back to 1.")
    return 1

def fallback_extract_text(pdf_path: Path) -> str:
    """
    Fallback to raw PyMuPDF text extraction if pymupdf4llm fails.

    Args:
        pdf_path (Path): Path to the PDF.

    Returns:
        str: Extracted text or empty string if failed.
    """
    try:
        doc = fitz.open(str(pdf_path))
        text = "\n\n".join(p.get_text("text") for p in doc)
        doc.close()
        vprint(f"Fallback: Extracted raw text from {pdf_path}")
        return text
    except Exception as e:
        logger.error(f"Fallback extraction failed: {e}")
        return ""

def extract_markdown_with_images(pdf_path: Path, out_dir: Path, flags_int: int = 1) -> Optional[Path]:
    """
    Extract Markdown and images from a PDF using pymupdf4llm with relative image paths.

    Args:
        pdf_path (Path): Path to the input PDF.
        out_dir (Path): Directory to save Markdown and images.
        flags_int (int): PyMuPDF text extraction flag.

    Returns:
        Optional[Path]: Path to the generated Markdown file, or None if extraction fails.
    """
    if not pdf_path.exists():
        logger.error(f"PDF not found: {pdf_path}")
        return None

    out_dir.mkdir(parents=True, exist_ok=True)
    images_dir = out_dir / IMAGE_DIR_NAME
    images_dir.mkdir(exist_ok=True)
    md_output_path = out_dir / MD_OUTPUT_NAME

    try:
        vprint(f"Extracting Markdown from {pdf_path} with flags={flags_int}")
        md_text = pymupdf4llm.to_markdown(
            doc=str(pdf_path.resolve()),
            write_images=True,
            image_path=str(images_dir),
            image_format="png",
            dpi=DPI,
            page_chunks=False,
            use_getText_options={'flags': int(flags_int)}
        )
        # Fix image paths to be relative (e.g., images/sample_arxiv.pdf-2-0.png)
        md_text = re.sub(
            r'!\[(.*?)\]\((.*?/)?' + re.escape(str(images_dir)) + r'[\\/](.*?)\)',
            r'![[\1]](images/\3)',  # Ensure relative path: images/filename.png
            md_text
        )
    except TypeError as e:
        vprint(f"use_getText_options not supported: {e}. Falling back to basic extraction.")
        try:
            md_text = pymupdf4llm.to_markdown(
                doc=str(pdf_path.resolve()),
                write_images=True,
                image_path=str(images_dir),
                image_format="png",
                dpi=DPI,
                page_chunks=False
            )
            md_text = re.sub(
                r'!\[(.*?)\]\((.*?/)?' + re.escape(str(images_dir)) + r'[\\/](.*?)\)',
                r'![[\1]](images/\3)',
                md_text
            )
        except Exception as e:
            logger.error(f"pymupdf4llm extraction failed: {e}")
            md_text = fallback_extract_text(pdf_path)
            if not md_text:
                return None

    try:
        md_output_path.write_text(md_text, encoding="utf-8")
        vprint(f"Markdown extracted to: {md_output_path}")
        return md_output_path
    except Exception as e:
        logger.error(f"Failed to write Markdown to {md_output_path}: {e}")
        return None

def normalize_alt_text(alt: str, src: str) -> str:
    """
    Normalize image alt text. Use filename if alt is empty.

    Args:
        alt (str): Original alt text.
        src (str): Image source path.

    Returns:
        str: Normalized and HTML-escaped alt text.
    """
    alt_clean = " ".join((alt or "").split()).strip()
    if not alt_clean:
        filename = Path(src).name
        alt_clean = re.sub(r"[_\-]+", " ", filename.rsplit(".", 1)[0])
    return html.escape(alt_clean)

def find_caption_after(lines: List[str], idx: int) -> Tuple[str, int]:
    """
    Find a caption in the lines following an image reference.

    Args:
        lines (List[str]): Markdown lines.
        idx (int): Index of the image reference line.

    Returns:
        Tuple[str, int]: (Caption text, line offset). Returns ("", 0) if no caption found.
    """
    caption_patterns = [
        re.compile(r'^\s*(Figure|Fig\.|図)\s*\d*[:：\-]\s*(.+)', re.I),
        re.compile(r'^\s*\*(.+)\*\s*$'),
        re.compile(r'^\s*<figcaption>(.+)</figcaption>\s*$', re.I)
    ]
    for offset in range(1, 4):
        if idx + offset >= len(lines):
            break
        candidate = lines[idx + offset].strip()
        if not candidate:
            continue
        for pat in caption_patterns:
            m = pat.match(candidate)
            if m:
                caption = m.group(2) if len(m.groups()) >= 2 and m.group(2) else m.group(1)
                return (caption.strip(), offset)
        if len(candidate.split()) <= 20 and re.match(r'^[A-Z0-9ぁ-んァ-ヴ一-龥]', candidate):
            return (candidate, offset)
    return ("", 0)

def refine_markdown(md_path: Path) -> Optional[Path]:
    """
    Refine Markdown by converting image references to <figure> tags with captions and ensuring relative paths.

    Args:
        md_path (Path): Path to the input Markdown file.

    Returns:
        Optional[Path]: Path to the refined Markdown file, or None if failed.
    """
    if not md_path.exists():
        logger.error(f"Markdown file not found: {md_path}")
        return None

    vprint(f"Refining Markdown: {md_path}")
    try:
        raw = md_path.read_text(encoding="utf-8")
        lines = raw.splitlines()
        out_lines = []
        img_pattern = re.compile(r'!\[(.*?)\]\((.*?)\)')
        fig_counter = 1
        i = 0
        while i < len(lines):
            line = lines[i]
            def _img_repl(match):
                nonlocal fig_counter
                alt_raw = match.group(1)
                src = match.group(2).strip()
                # Ensure src is relative (e.g., images/sample_arxiv.pdf-2-0.png)
                src = re.sub(r'.*?' + re.escape(str(OUT_DIR)) + r'[\\/]?(.*)', r'\1', src)
                if not src.startswith("images/"):
                    src = f"images/{Path(src).name}"
                alt_norm = normalize_alt_text(alt_raw, src)
                fig_id = f"fig-{fig_counter:03d}"
                fig_counter += 1
                img_html = f'<img src="{html.escape(src)}" alt="{alt_norm}" data-llm-desc="{alt_norm}" />'
                figure_html = f'<figure id="{fig_id}">{img_html}</figure>'
                return figure_html

            new_line = img_pattern.sub(_img_repl, line)
            if "<figure" in new_line:
                caption_text, offset = find_caption_after(lines, i)
                if caption_text:
                    figcap_html = f'<figcaption>{html.escape(caption_text)}</figcaption>'
                    new_line = new_line.replace("</figure>", f"{figcap_html}</figure>")
                    vprint(f"Caption detected (line {i}): {caption_text}")
                    i += offset
            out_lines.append(new_line)
            i += 1

        refined_text = "\n".join(out_lines)
        md_refined_path = md_path.with_name(md_path.stem + "_refined.md")
        md_refined_path.write_text(refined_text, encoding="utf-8")
        vprint(f"Refined Markdown saved to: {md_refined_path}")
        return md_refined_path
    except Exception as e:
        logger.error(f"Failed to refine Markdown: {e}")
        return None

def create_zip_output(out_dir: Path, md_path: Path) -> Optional[Path]:
    """
    Create a zip file containing the Markdown and images.

    Args:
        out_dir (Path): Output directory containing Markdown and images.
        md_path (Path): Path to the Markdown file.

    Returns:
        Optional[Path]: Path to the created zip file, or None if failed.
    """
    if not md_path.exists():
        logger.error(f"Cannot create zip: Markdown file {md_path} not found")
        return None

    zip_path = out_dir / ZIP_PATH
    images_dir = out_dir / IMAGE_DIR_NAME
    try:
        with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
            if md_path.exists():
                z.write(md_path, arcname=md_path.relative_to(out_dir))
            if images_dir.exists():
                for imgfile in images_dir.glob("*.png"):
                    z.write(imgfile, arcname=imgfile.relative_to(out_dir))
        vprint(f"Created zip: {zip_path}")
        return zip_path
    except Exception as e:
        logger.error(f"Failed to create zip: {e}")
        return None

def main():
    """Main function to process the PDF and generate Markdown with linked images."""
    # Download PDF if it doesn't exist
    if not download_pdf(ARXIV_PDF_URL, PDF_PATH):
        logger.error("Aborting: PDF download or verification failed.")
        return

    # Choose safe flag
    flag = choose_safe_flag()

    # Extract Markdown and images
    md_path = extract_markdown_with_images(PDF_PATH, OUT_DIR, flag)
    if not md_path:
        logger.error("Aborting: Markdown extraction failed.")
        return

    # Refine Markdown
    refined_md_path = refine_markdown(md_path)
    if not refined_md_path:
        logger.error("Aborting: Markdown refinement failed.")
        return

    # Create zip file
    zip_path = create_zip_output(OUT_DIR, refined_md_path)
    if not zip_path:
        logger.error("Aborting: Zip creation failed.")
        return

    logger.info("\nWorkflow completed successfully!")
    logger.info(f"Refined Markdown: {refined_md_path}")
    logger.info(f"Images directory: {OUT_DIR / IMAGE_DIR_NAME}")
    logger.info(f"Zip file: {zip_path}")

    # Trigger Colab download if available
    try:
        from google.colab import files
        files.download(str(zip_path))
    except ImportError:
        logger.info("Not in Colab environment. Zip file available at:", zip_path)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.error(f"Workflow failed: {e}", exc_info=True)

